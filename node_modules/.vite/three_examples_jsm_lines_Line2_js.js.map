{
  "version": 3,
  "sources": ["../three/examples/jsm/lines/LineSegments2.js", "../three/examples/jsm/lines/Line2.js"],
  "sourcesContent": ["import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4\n} from 'three';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth( camera, distance, lineWidth, resolution ) {\n\n\t// transform into clip space, adjust the x and y values by the pixel width offset, then\n\t// transform back into world space to get world offset. Note clip space is [-1, 1] so full\n\t// width does not need to be halved.\n\t_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t_clipToWorldVector.x = lineWidth / resolution.width;\n\t_clipToWorldVector.y = lineWidth / resolution.height;\n\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\n\treturn Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );\n\n}\n\nclass LineSegments2 extends Mesh {\n\n\tconstructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'LineSegments2';\n\n\t}\n\n\t// for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\t\tconst lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\tfor ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t_start.fromBufferAttribute( instanceStart, i );\n\t\t\t_end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );\n\n\t\t}\n\n\t\tconst instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( raycaster.camera === null ) {\n\n\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.' );\n\n\t\t}\n\n\t\tconst threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\tconst ray = raycaster.ray;\n\t\tconst camera = raycaster.camera;\n\t\tconst projectionMatrix = camera.projectionMatrix;\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\t\tconst resolution = material.resolution;\n\t\tconst lineWidth = material.linewidth + threshold;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\n\t\t// camera forward is negative\n\t\tconst near = - camera.near;\n\n\t\t//\n\n\t\t// check if we intersect the sphere bounds\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\t\tconst distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( ray.origin ) );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tconst sphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, lineWidth, resolution );\n\t\t_sphere.radius += sphereMargin;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t//\n\n\t\t// check if we intersect the box bounds\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\t_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\t\tconst distanceToBox = Math.max( camera.near, _box.distanceToPoint( ray.origin ) );\n\n\t\t// increase the box bounds by the worst case line screen space width\n\t\tconst boxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, lineWidth, resolution );\n\t\t_box.max.x += boxMargin;\n\t\t_box.max.y += boxMargin;\n\t\t_box.max.z += boxMargin;\n\t\t_box.min.x -= boxMargin;\n\t\t_box.min.y -= boxMargin;\n\t\t_box.min.z -= boxMargin;\n\n\t\tif ( raycaster.ray.intersectsBox( _box ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t//\n\n\t\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t\t// applying the projection matrix.\n\t\tray.at( 1, _ssOrigin );\n\n\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t_ssOrigin.w = 1;\n\t\t_ssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t\t_ssOrigin.applyMatrix4( projectionMatrix );\n\t\t_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );\n\n\t\t// screen space\n\t\t_ssOrigin.x *= resolution.x / 2;\n\t\t_ssOrigin.y *= resolution.y / 2;\n\t\t_ssOrigin.z = 0;\n\n\t\t_ssOrigin3.copy( _ssOrigin );\n\n\t\t_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\t\tfor ( let i = 0, l = instanceStart.count; i < l; i ++ ) {\n\n\t\t\t_start4.fromBufferAttribute( instanceStart, i );\n\t\t\t_end4.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t_start4.w = 1;\n\t\t\t_end4.w = 1;\n\n\t\t\t// camera space\n\t\t\t_start4.applyMatrix4( _mvMatrix );\n\t\t\t_end4.applyMatrix4( _mvMatrix );\n\n\t\t\t// skip the segment if it's entirely behind the camera\n\t\t\tconst isBehindCameraNear = _start4.z > near && _end4.z > near;\n\t\t\tif ( isBehindCameraNear ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// trim the segment if it extends behind camera near\n\t\t\tif ( _start4.z > near ) {\n\n\t\t\t\tconst deltaDist = _start4.z - _end4.z;\n\t\t\t\tconst t = ( _start4.z - near ) / deltaDist;\n\t\t\t\t_start4.lerp( _end4, t );\n\n\t\t\t} else if ( _end4.z > near ) {\n\n\t\t\t\tconst deltaDist = _end4.z - _start4.z;\n\t\t\t\tconst t = ( _end4.z - near ) / deltaDist;\n\t\t\t\t_end4.lerp( _start4, t );\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\t_start4.applyMatrix4( projectionMatrix );\n\t\t\t_end4.applyMatrix4( projectionMatrix );\n\n\t\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t\t_start4.multiplyScalar( 1 / _start4.w );\n\t\t\t_end4.multiplyScalar( 1 / _end4.w );\n\n\t\t\t// screen space\n\t\t\t_start4.x *= resolution.x / 2;\n\t\t\t_start4.y *= resolution.y / 2;\n\n\t\t\t_end4.x *= resolution.x / 2;\n\t\t\t_end4.y *= resolution.y / 2;\n\n\t\t\t// create 2d segment\n\t\t\t_line.start.copy( _start4 );\n\t\t\t_line.start.z = 0;\n\n\t\t\t_line.end.copy( _end4 );\n\t\t\t_line.end.z = 0;\n\n\t\t\t// get closest point on ray to segment\n\t\t\tconst param = _line.closestPointToPointParameter( _ssOrigin3, true );\n\t\t\t_line.at( param, _closestPoint );\n\n\t\t\t// check if the intersection point is within clip space\n\t\t\tconst zPos = MathUtils.lerp( _start4.z, _end4.z, param );\n\t\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\t\tconst isInside = _ssOrigin3.distanceTo( _closestPoint ) < lineWidth * 0.5;\n\n\t\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t\t_line.start.applyMatrix4( matrixWorld );\n\t\t\t\t_line.end.applyMatrix4( matrixWorld );\n\n\t\t\t\tconst pointOnLine = new Vector3();\n\t\t\t\tconst point = new Vector3();\n\n\t\t\t\tray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\n\t\t\t\tintersects.push( {\n\n\t\t\t\t\tpoint: point,\n\t\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\t\tdistance: ray.origin.distanceTo( point ),\n\n\t\t\t\t\tobject: this,\n\t\t\t\t\tface: null,\n\t\t\t\t\tfaceIndex: i,\n\t\t\t\t\tuv: null,\n\t\t\t\t\tuv2: null,\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nLineSegments2.prototype.isLineSegments2 = true;\n\nexport { LineSegments2 };\n", "import { LineSegments2 } from '../lines/LineSegments2.js';\nimport { LineGeometry } from '../lines/LineGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nclass Line2 extends LineSegments2 {\n\n\tconstructor( geometry = new LineGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'Line2';\n\n\t}\n\n}\n\nLine2.prototype.isLine2 = true;\n\nexport { Line2 };\n"],
  "mappings": "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",
  "names": []
}
